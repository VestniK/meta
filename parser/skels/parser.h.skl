@("int8_t", "uint8_t", "int16_t", "uint16_t", "int", "uint", "const char*")
@//
// Generated by: @program; @version;
// Grammar:      @grm_file;
// Skeleton:     @skl_file;
// Output:       @out_file;
#ifndef @grm_name;_parser_h
#define @grm_name;_parser_h

#include <cstdint>
#include <cstdlib>
#include <stdexcept>
#include <memory>
#include <type_traits>
#include <typeindex>
#include <typeinfo>
#include <vector>

#include "@grm_name;lexer.h"

namespace @grm_name; {
@def_cons?;...

// Terminal state num constants
enum Terminal
{
    @def_cons.1|%s = %d||,\n    |;
};
@@
@numb_node?;...

// Base AST node class
class Node;
// Node subclassess to be implemented in the user code
@node_name.1|class %s\;||\n|;
@@

// Parser state which is stored in the stack
struct StackFrame
{
    int state;
    int symbol; // Symbol stacked, terminal (positive) or nonterminal (negative).
    TokenSequence tokens;
@numb_node?;...
    std::vector<Node *> nodes;
@@
};

class SyntaxError: public std::exception
{
public:
    SyntaxError(const std::string &src, const char *input, size_t size, StackFrame *stack, size_t stackSz, int stateNum, const Token &token);
    virtual const char *what() const noexcept override {return msg.c_str();}
    const std::string &sourcePath() const {return src;}
    const Token token() const {return errorToken;}
    const std::string &line() const {return markedLine;}
@optn_exp?;...
    const std::string &expected() const {return expectedLine;}
@@
@optn_exp.gt.1;...
    const std::string &parserStack() const {return stackDump;}
@@

private:
    std::string msg;
    std::string markedLine;
@optn_exp?;...
    std::string expectedLine;
@@
@optn_exp.gt.1;...
    std::string stackDump;
@@
    Token errorToken;
    std::string src;

    static @term_symb.t; termNames[];
@optn_exp?;...
    static const size_t termsCount;
@@
@optn_exp.gt.1;...
    static @head_symb.t; nontermNames[];
@@
};
@numb_node?;...

class Visitor
{
public:
    virtual ~Visitor() {}

    // return true to travers children or false to skip them
    virtual bool visit(Node *) {return true;}
    virtual void leave(Node *) {}
    @node_name.1|virtual bool visit(%s *)\;||\n    |;
    @node_name.1|virtual void leave(%s *)\;||\n    |;

protected:
    Visitor() {}
};

enum WalkDirection {
    /// Visit node then traverse children
    TopDown,
    /// Traverse children then visit node
    BottomUp
};

constexpr int infinitDepth = -1;

namespace internals {

template<typename Func, class NodeSubclass, WalkDirection dir> class FuncVisitor;

template<typename Func, class NodeSubclass>
class FuncVisitor<Func, NodeSubclass, TopDown>: public Visitor
{
public:
    FuncVisitor(Func &&func): func(std::forward<Func>(func)) {}

    virtual bool visit(NodeSubclass *node) override {return std::forward<Func>(func)(node);}
private:
    Func &&func;
};

template<typename Func, class NodeSubclass>
class FuncVisitor<Func, NodeSubclass, BottomUp>: public Visitor
{
public:
    FuncVisitor(Func &&func): func(std::forward<Func>(func)) {}

    virtual void leave(NodeSubclass *node) override {std::forward<Func>(func)(node);}
private:
    Func &&func;
};

} // namespace internals

template<class NodeSubclass, WalkDirection dir, typename Walkable, typename Func>
inline
void walk(Walkable &walkable, Func &&func, int depth = infinitDepth)
{
    internals::FuncVisitor<Func, NodeSubclass, dir> visitor(std::forward<Func>(func));
    walkable.walk(&visitor, depth);
}

template<class NodeSubclass, WalkDirection dir, typename Walkable, typename Func>
inline
void walk(Walkable *walkable, Func &&func, int depth = infinitDepth)
{
    internals::FuncVisitor<Func, NodeSubclass, dir> visitor(std::forward<Func>(func));
    walkable->walk(&visitor, depth);
}

class AST
{
public:
    virtual ~AST() {}

    void walk(Visitor *visitor, int depth = infinitDepth);

    template<class T>
    std::vector<T*> getChildren(int depth = 1)
    {
        std::vector<T*> res;
        @grm_name;::walk<T, TopDown>(*this, [&res](T *node) {res.push_back(node); return true;}, depth);
        return std::move(res);
    }

private:
    virtual std::vector<Node *> &roots() = 0;
};

class Node
{
public:
    Node(const StackFrame *reduction, size_t size);
    virtual ~Node() {}

    void walk(Visitor *visitor, int depth = infinitDepth);

    template<class T>
    std::vector<T*> getChildren(int depth = 1)
    {
        std::vector<T*> res;
        @grm_name;::walk<T, TopDown>(*this, [&res, this](T *node) {
            if (static_cast<Node*>(node) != this)
                res.push_back(node);
            return true;
        }, depth);
        return std::move(res);
    }

    const TokenSequence &tokens() const {return srcTokens;}
    const std::string &sourcePath() const {return src;}
    void setSourcePath(const std::string &val) {src = val;}

    /// Returns type index of the nearest VisitableNode base class of a real node
    virtual std::type_index getVisitableType() = 0;

protected:
    virtual bool accept(Visitor *visitor) = 0;
    virtual void seeOff(Visitor *visitor) = 0;

protected:
    std::vector<Node *> children;

private:
    TokenSequence srcTokens;
    std::string src;
};

template<typename Func, typename... Args>
inline
auto dispatch(Func &&func, Node *node, Args&&... args) {
    auto type = node->getVisitableType();
    if (false) {}
    @node_name.1|else if (type == std::type_index(typeid(%s))) return std::forward<Func>(func)(static_cast<%s*>(node), std::forward<Args>(args)...)\;||\n        |;
    return std::forward<Func>(func)(node, std::forward<Args>(args)...);
}

namespace internals {

// simplified C++17 std::invoke to handle f(node, args...) and node->f(args...) cases properly
template<bool memberFunc, typename NodeSubclass, typename Func, typename... Args> struct invoker;

template<typename NodeSubclass, typename Func, typename... Args>
struct invoker<false, NodeSubclass, Func, Args...> {
    inline static auto invoke(Func &&func, NodeSubclass *node, Args&&... args) {
        return std::forward<Func>(func)(node, std::forward<Args>(args)...);
    }
};

template<typename NodeSubclass, typename Func, typename... Args>
struct invoker<true, NodeSubclass, Func, Args...> {
    inline static auto invoke(Func func, NodeSubclass *node, Args&&... args) {
        return (node->*func)(std::forward<Args>(args)...);
    }
};

} // namespace internals

template<typename NodeSubclass, typename Func, typename... Args>
inline
auto invoke(Func &&func, Node *node, Args&&... args) {
    typedef typename std::result_of<Func&&(NodeSubclass*, Args&&...)>::type Ret;
    struct {
        inline Ret operator() (Node *, Args&&...) {
            throw std::invalid_argument("Attempt to invoke function on incorrect node type");
        }
        inline Ret operator() (NodeSubclass *node, Args&&...args) {
            return internals::invoker<
                std::is_member_function_pointer<Func>::value,
                NodeSubclass, Func, Args...
            >::invoke(std::forward<Func>(func), node, std::forward<Args>(args)...);
        }
        Func &&func;
    } dispatchable = {std::forward<Func>(func)};
    return dispatch(dispatchable, node, std::forward<Args>(args)...);
}

template<typename Base, typename Impl>
class Visitable: public Base {
    virtual std::type_index getVisitableType() override {return std::type_index(typeid(Impl));}
protected:
    Visitable(const StackFrame *reduction, size_t size): Base(reduction, size) {}

    virtual bool accept(Visitor *visitor) override {return visitor->visit(static_cast<Impl*>(this));}
    virtual void seeOff(Visitor *visitor) override {visitor->leave(static_cast<Impl*>(this));}
};
@numb_nact?;...

class NodeActions
{
public:
    virtual ~NodeActions() {}

    @nact_func.1|virtual void on%s(%s *node) = 0\;||\n    |;
};
@@
@@
@numb_tact?;...

// Token actions interface
class TokenActions
{
public:
    virtual ~TokenActions() {}

    @tact_func.1|virtual void %s(int terminalNumb, const Token &token) = 0\;||\n        |;
};
@@
@numb_pact?;...

class ParseActions
{
public:
    virtual ~ParseActions() {}

    @pact_func.1|virtual void %s(const StackFrame *reduction, size_t size) = 0\;||\n    |;
};
@@

@numb_node?;...
class Parser: private AST
@@
@numb_node!;...
class Parser
@@
{
public:
    // Parser methods
    Parser();
    ~Parser();

    void setSourcePath(const std::string &val) {src = val;}

@numb_tact?;...
    void setTokenActions(TokenActions *actions) {tokenActions = actions;}
@@
@numb_pact?;...
    void setParseActions(ParseActions *actions) {parseActions = actions;}
@@
@numb_nact?;...
    void setNodeActions(NodeActions *actions) {nodeActions = actions;}
@@
    void parse(const char *input, size_t size);
    // Overloaded treats strlen as input size
    void parse(const char *input);

@numb_node?;...
    AST *ast() {return this;}
@@

// Internal methods
private:
    void reduce(int prodRule);

@numb_node?;...
    void addNode(Node *node);
    virtual std::vector<Node *> &roots() override {return mRoots;}
@@

// Class data
private:
    Lexer lexer;
    std::string src;
@numb_tact?;...
    TokenActions *tokenActions;
@@
@numb_pact?;...
    ParseActions *parseActions;
@@
@numb_nact?;...
    NodeActions *nodeActions;
@@
    std::vector<StackFrame> stack;
    size_t stackTop;
@numb_node?;...
    std::vector<Node *> mRoots;
    std::vector< std::unique_ptr<Node> > nodes;
@@
    static const size_t stackIncrementStep;
    int stateNum;

// Internal grammar constants
private:
    friend class SyntaxError;
    static const int acceptState;

    // Production rule length minus one(zero based).
    static const @prod_leng.t; prodLen[];

    // Boolean matrix parser tables
    static const @bmat_numb.t; Bm[]; // matrix data.
    static const @bmat_row.t; Br[]; // row(base).
    static const @bmat_col.t; Bc[]; // column(displacement).
@optn_bm.eq.2;...
    static const @bmat_mask.t; Bmask[]; // masks.
@@

    // Terminal transition matrix(gives next state or reduction).
    static const @tmat_numb.t; Tm[]; // matrix data.
    static const @tmat_row.t; Tr[]; // row(base).
    static const @tmat_col.t; Tc[]; // column(displacement).

    // Nonterminal transition matrix(gives next state or reduction).
    static const @nmat_numb.t; Nm[]; // matrix data.
    static const @nmat_row.t; Nr[]; // row(base).
    static const @nmat_col.t; Nc[]; // column(displacement).

    // Reduction matrix(gives reduction).
    static const @rmat_numb.t; Rm[]; // matrix data.
    static const @rmat_row.t; Rr[]; // row(base).
    static const @rmat_col.t; Rc[]; // column(displacement).

@numb_tact?;...
    // Get token action number by terminal number
    static const @tact_numb.t; tokenActionNumber[];
@@
@numb_pact?;...
    // Get parser action number by terminal number
    static const @pact_numb.t; parseActionNumber[];
@@
@numb_nact?;...
    // Node action number
    static const @nact_numb.t; nodeActionNumber[];
@@
    // Get grammar nonterminal symbol number by terminal number
    static const @prod_head.t; nonterminalNumber[];
@numb_node?;...
    // Get id of a node to be created by production number
    static const @node_numb.t; nodeNumber[];
@@
};

} // namespace @grm_name;

#endif // @grm_name;_parser_h
