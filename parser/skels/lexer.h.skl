@("int8_t", "uint8_t", "int16_t", "uint16_t", "int", "uint", "const char*")
@//
// Generated by: @program; @version;
// Grammar:      @grm_file;
// Skeleton:     @skl_file;
// Output:       @out_file;
#ifndef @grm_name;_lexer_h
#define @grm_name;_lexer_h

#include <cstdint>
#include <string>

namespace @grm_name; {

struct Token
{
    int termNum = 0;
    const char* start = nullptr;
    const char* end = nullptr;
@optn_line?;...
    int line = 0;
@@
@optn_col?;...
    int column = 0;

    // Returns string from the beggining of line till the end of this token
    // sequence
    std::string lineStr() const;
@@
    inline operator std::string () const {return std::string(start, end);}
    // Token points to a data but not own them. If one want to store token for longer time than lexer input
    // lifetime then it's necessary to copy token content and reference copied data. Important example is
    // holding token inside an exception.
    void detach(std::string &dst);
};

class Lexer
{
public:
    Lexer() {}

    void start(
        const char *input
@optn_line?;...
        , int line = 1
@@
@optn_col?;...
        , int column = 1
@@
    );
    void next();
    const Token &currentToken() const {return token;}

@def_cons?;...
    enum tokens
    {
        @def_cons.1|%s = %d||,\n        |;
    };

@@
private:
    Token token;
@optn_line?;...
    int line;
@@
@optn_col?;...
    int column;
@@

    static const int tab;
@strings?;...
    static const char *string[]; // Strings, if strings were used instead of numbers
@@
@def_cons?;...
    static const char *token_name[]; // Token names, if names were used instead of numbers.
@@

@optn_small?;...
    static const @bmat_numb.6t; Bm[]; // Bit matrix (0 or 1).
    static const @bmat_row. 6t; Br[]; // Bit matrix row (base).
    static const @bmat_col. 6t; Bc[]; // Bit matrix column (displacement).

@@
    static const @tmat_numb.6t; Tm[]; // Terminal transition matrix (gives next state or reduction).
    static const @tmat_row. 6t; Tr[]; // Terminal transition matrix row (base).
    static const @tmat_col. 6t; Tc[]; // Terminal transition matrix column (displacement).

    static const @term_numb.6t; terminal[]; // Terminal-symbol number for symbol recognized.
};

// Lexer wrapper to iterate over tokens with iterators and foreach loop.
class TokenSequence
{
public:
    TokenSequence() = default;
    // Create sequence containing single element
    TokenSequence(const Token &elem);
    // Create sequence from token first to token last includiong both of them
    TokenSequence(const Token &first, const Token &last);

    class iterator {
    public:
        bool operator!= (const iterator &other) const;
        bool operator== (const iterator &other) const {return !(*this != other);}
        const Token &operator* () const;
        const Token *operator-> () const;
        iterator &operator++ ();

    private:
        friend class TokenSequence;
        iterator(
            const char *begin, const char *end
@optn_line?;...
            , int line
@@
@optn_col?;...
            , int colunm
@@
        );
        iterator();

        Lexer lexer;
        const char *end;
    };

    void setFirst(const Token &first);
    void setLast(const Token &last);
    void join(const TokenSequence &other);

    bool empty() const;
@optn_line?;...
    int linenum() const {return line;}
@@
@optn_col?;...
    int colnum() const {return column;}
    // Returns string from the beggining of the first token line till the end of the last token in this
    // sequence
    std::string lineStr() const;
@@
    inline operator std::string () const {return std::string(beginPos, endPos);}
    // TokenSequence points to a data but not own them. If one want to store it for a longer time than lexer
    // input lifetime then it's necessary to copy data referenced by sequence and reference copied data.
    // Important example is holding token sequence inside an exception.
    void detach(std::string &dst);

    iterator begin() const;
    iterator end() const;

private:
    const char *beginPos = nullptr;
    const char *endPos = nullptr;
@optn_line?;...
    int line = 0;
@@
@optn_col?;...
    int column = 0;
@@
};

} // namespace @grm_name;

#endif // @grm_name;_lexer_h

